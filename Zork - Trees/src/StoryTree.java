/**
 * The StoryTree class represents the primary data structure for the Zork 
 * game. This class should be a ternary (3-child) tree of StoryTreeNodes, 
 * which are structured as a continuous chain of decisions the user may make
 *  to reach the end of the game (any leaf node).
 * 
 * @author Bryan Wong
 * 		SBUID#115226034
 * 		Recitation#04
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.zip.DataFormatException;

public class StoryTree {
	StoryTreeNode root; // root reference
	StoryTreeNode cursor; // cursor reference
	GameState state; 
	
	/**
	 * Returns an instance of StoryTree
	 */
	public StoryTree() {
		root = new StoryTreeNode("root", "root", "Hello, and welcome to "
				+ "Zork!");
		cursor = root;
		state = GameState.GAME_NOT_OVER;
	}
	
	/**
	 * Reads in a text file describing a StoryTree. If the text file does not 
	 * exist, then a new one will be made using the inputed name.
	 * 
	 * @param fileName
	 *    Name of the file to read from.
	 * 
	 * @precondition
	 *    filename is a non-null, non-empty String that points to a file that 
	 *    exists that is readable, and is valid.
	 *    
	 * @return
	 *    A new StoryTree generated by the passed in text file is returned.
	 * 
	 * @throws IllegalArgumentException
	 *    filename is empty or null.
	 *    
	 * @throws DataFormatException
	 *    The file contained data inconsistent with the expected data format 
	 * 
	 * @throws TreeFullException
	 *    The tree is full
	 *    
	 * @throws FileNotFoundException
	 *    File is not found
	 */
	public static StoryTree readTree(String fileName) 
			throws IllegalArgumentException, DataFormatException, 
			TreeFullException, FileNotFoundException {
		if (fileName == null || fileName.isEmpty()) {
			throw new IllegalArgumentException("fileName is empty or null");
		}
		else {
			try {
				File file = new File(fileName);
				Scanner fileIn = new Scanner(file);
				StoryTree tree = new StoryTree();
				
				while (fileIn.hasNextLine()) {
					String line = fileIn.nextLine();
					String[] input = line.split(" \\| ");
					
					if (input.length != 3) {
						throw new DataFormatException("inconsistent with "
								+ "expected data format");
					}
					StoryTreeNode tempCursor = tree.root;
					String position = input[0];
					String option = input[1];
					String message = input[2];
					String[] positionSplit = position.split("-");
					StoryTreeNode node = new StoryTreeNode(position, option,
							message);
					for (int i = 0; i < positionSplit.length; i++) {
						if (i == positionSplit.length-1) {
			                if (positionSplit[i].equals("1")) {
			                    tempCursor.setLeftChild(node);
			                }
			                else if (positionSplit[i].equals("2")) {
			                    tempCursor.setMiddleChild(node);
			                }
			                else if (positionSplit[i].equals("3")) {
			                    tempCursor.setRightChild(node);
			                }
			                else {
			                    throw new DataFormatException("something went "
			                    		+ "wrong");
			                }
						}
						else {
							switch (positionSplit[i]) {
								case "1":
									tempCursor = tempCursor.getLeftChild();
									break;
								case "2":
									tempCursor = tempCursor.getMiddleChild();
									break;
								case "3":
									tempCursor = tempCursor.getRightChild();
									break;
							}
						}
					}
				}
				tree.resetCursor();
				fileIn.close();
				return tree;
			}
			catch (FileNotFoundException e) {
				StoryTree fresh = new StoryTree();
				return fresh;
			}
		}
	}
	
	/**
	 * Saves a StoryTree to the indicated file using the specified data format
	 * 
	 * @param fileName
	 *    Name of the file to read from.
	 *    
	 * @param tree
	 *    A reference to the tree to save to the indicated file.
	 *    
	 * @precondition
	 *    tree is non-null.
	 *    filename is a non-null, non-empty String.
	 *    
	 * @throws IllegalArgumentException
	 *    tree is null.
	 *    filename is empty or null.
	 *    
	 * @throws FileNotFoundException
	 *    File not found
	 */
	public static void saveTree(String fileName, StoryTree tree) 
			throws IllegalArgumentException, FileNotFoundException {
		if (fileName == null || fileName.isEmpty()) {
			throw new IllegalArgumentException("filename is empty or null");
		}
		else if (tree == null) {
			throw new IllegalArgumentException("Tree is null");
		}
		else {
			try {
				PrintWriter fileOut = new PrintWriter(fileName);
				tree.resetCursor();
				tree.cursor = tree.cursor.getLeftChild();
				tree.traverse(tree.cursor, fileOut);
				
				
				fileOut.close();
			} catch (FileNotFoundException e) {
				throw new FileNotFoundException("file not found");
			}
		}
		
	}
	
	/**
	 * Gets the current state of the game
	 * 
	 * @precondition 
	 *    state is not null.
	 *    
	 * @return
	 *    the GameState of the StoryTree as a GameState enum
	 */
	public GameState getGameState() {
		return state;
	}
	
	/**
	 * Gets the current position of the cursor.
	 * 
	 * @return
	 *    the cursor's position as a String
	 */
	public String getCursorPosition() {
		return cursor.getPosition();
	}
	
	/**
	 * Gets the current message of the cursor.
	 * 
	 * @return
	 *    the cursor's message as a String
	 */
	public String getCursorMessage() {
		return cursor.getMessage();
	}
	
	/**
	 * Returns an array of String pairs - {position, option} for each 
	 * immediate child of the cursor
	 * 
	 * @return
	 *    the position and options pairs as a 2D String array
	 */
	public String[][] getOptions() {
		String[][] options = new String[3][2];
		if (cursor.getLeftChild() == null) {
			options[0][0] = null;
			options[0][1] = null;
		}
		else {
			options[0][0] = cursor.getLeftChild().getPosition();
			options[0][1] = cursor.getLeftChild().getOption();
		}
		if (cursor.getMiddleChild() == null) {
			options[1][0] = null;
			options[1][1] = null;
		}
		else {
			options[1][0] = cursor.getMiddleChild().getPosition();
			options[1][1] = cursor.getMiddleChild().getOption();
		}
		if (cursor.getRightChild() == null) {
			options[2][0] = null;
			options[2][1] = null;
		}
		else {
			options[2][0] = cursor.getRightChild().getPosition();
			options[2][1] = cursor.getRightChild().getOption();
		}
		return options;
	}
	
	/**
	 * Sets the message for the current cursor.
	 * 
	 * @param message
	 *    the new message
	 */
	public void setCursorMessage(String message) {
		cursor.setMessage(message);
	}
	
	/**
	 * Sets the option for the current cursor
	 * 
	 * @param option
	 *    the new option
	 */
	public void setCursorOption(String option) {
		cursor.setOption(option);
	}
	
	/**
	 * Resets the cursor to the root node.
	 * 
	 * @precondition
	 *    Cursor references root node.
	 */
	public void resetCursor() {
		cursor = root;
	}
	/**
	 * Selects the child with the name indicated by position.
	 * 
	 * @param position
	 *    The position String of the child to node to select.
	 * 
	 * @precondition
	 *    The child with the indicated position member variable exists as a 
	 *    direct child of the cursor.
	 * 
	 * @postcondition
	 *    Cursor references node indicated by position.
	 * 
	 * @throws IllegalArgumentException
	 *    position is empty or null.
	 * 
	 * @throws NodeNotPresentException
	 *    Node with indicated position variable was not found. 
	 */
	public void selectChild(String position) throws NodeNotPresentException {
		if (position == null || position.equals("")) {
			throw new IllegalArgumentException("position is empty or null");
		}
		StoryTreeNode hold = cursor;
		switch (position.substring(position.length()-1)) {
			case "1":
				hold = hold.getLeftChild();
				break;
				
			case "2":
				hold = hold.getMiddleChild();
				break;
				
			case "3":
				hold = hold.getRightChild();
				break;
		}
		if (hold == null) {
			throw new NodeNotPresentException("Node with indicated position "
					+ "variable was not found");
		}
		cursor = hold;
	}
	
	/**
	 * Adds a new child under the current cursor, with given option and 
	 * message.
	 * 
	 * @param option
	 *    The new String to set as the option of the new child.
	 * 
	 * @param message
	 *    The new String to set as the message of the new child.
	 * 
	 * @postcondition
	 *    Cursor has new child, with specified message and option.
	 * 
	 * @throws IllegalArgumentException
	 *    Either String is empty or null.
	 * 
	 * @throws TreeFullException
	 *    All three child spots are already full.
	 */
	public void addChild(String option, String message) 
			throws IllegalArgumentException, TreeFullException {
		if (option == null || message == null || option.equals("") 
				|| message.equals("")) {
			throw new IllegalArgumentException("Either is string is null or "
					+ "empty");
		}
		else if (cursor.getLeftChild() != null && cursor.getMiddleChild() 
				!= null && cursor.getRightChild() != null) {
			throw new TreeFullException("All three child spots are already "
					+ "full");
		}
		else {
			if (cursor.getLeftChild() == null) {
				StoryTreeNode node = new StoryTreeNode(cursor.getPosition() 
						+ "-1", option, message);
				cursor.setLeftChild(node);
				cursor = cursor.getLeftChild();
			}
			else if (cursor.getMiddleChild() == null) {
				StoryTreeNode node = new StoryTreeNode(cursor.getPosition() 
						+ "-2", option, message);
				cursor.setMiddleChild(node);
				cursor = cursor.getMiddleChild();
			}
			else if (cursor.getRightChild() == null) {
				StoryTreeNode node = new StoryTreeNode(cursor.getPosition() 
						+ "-3", option, message);
				cursor.setRightChild(node);
				cursor = cursor.getRightChild();
			}
			
		}
	}
	
	/**
	 * Removes an immediate child under the current cursor. This method 
	 * implicitly removes the entire sub-tree for which the indicated child 
	 * is root.ldren of the cursor.
	 * 
	 * @param position
	 *    String indicating the position of the child to be removed.
	 * 
	 * @precondition
	 *    The child with the indicated position member variable exists as a 
	 *    direct child of the cursor.
	 * 
	 * @postcondition
	 *    The indicated child and it's entire sub-tree have been removed from 
	 *    the tree.
	 * 
	 * @return
	 *    A reference to the child removed
	 * 
	 * @throws NodeNotPresentException
	 *    Node with indicated position variable was not found.
	 */
	public StoryTreeNode removeChild(String position) 
			throws NodeNotPresentException {
		StoryTreeNode temp = null;
		switch (position.substring(position.length()-1)) {
			case "1":
				if (cursor.getLeftChild() == null) {
					throw new NodeNotPresentException("no left node");
				}
				temp = cursor.getLeftChild();
				cursor.setLeftChild(null);
				cursor.setLeftChild(cursor.getMiddleChild());
				if (cursor.getLeftChild() != null) {
					renamingChildren(cursor.getLeftChild(), 
							cursor.getLeftChild(), "1");
				}
				cursor.setMiddleChild(cursor.getRightChild());
				if (cursor.getMiddleChild() != null) {
					renamingChildren(cursor.getMiddleChild(), 
							cursor.getMiddleChild(), "2");
				}
				cursor.setRightChild(null);
				return temp;
			case "2":
				if (cursor.getMiddleChild() == null) {
					throw new NodeNotPresentException("no middle node");
				}
				temp = cursor.getMiddleChild();
				cursor.setMiddleChild(null);
				cursor.setMiddleChild(cursor.getRightChild());
				if (cursor.getMiddleChild() != null) {
					renamingChildren(cursor.getMiddleChild(), 
							cursor.getMiddleChild(), "2");
				}
				cursor.setRightChild(null);
				return temp;
			case "3":
				if (cursor.getRightChild() == null) {
					throw new NodeNotPresentException("no right node");
				}
				temp = cursor.getRightChild();
				cursor.setRightChild(null);
				return temp;
		}			
		if (temp == null) {
			throw new NodeNotPresentException("impossible case");
		}
		return temp;
	}
	
	/**
	 * Traverses recursively using preorder traversal through the tree 
	 * writing the details of each node into the txt file 
	 * 
	 * @param node
	 * @param fileOut
	 */
	public void traverse(StoryTreeNode node, PrintWriter fileOut) {
		if (node == null) {
			return;
		}
		
		fileOut.println(node.getPosition() + " | " + node.getOption() + " | " 
		+ node.getMessage());
		
		traverse(node.getLeftChild(), fileOut);
		traverse(node.getMiddleChild(), fileOut);
		traverse(node.getRightChild(), fileOut);
	}
	
	/**
	 * Traverses recursively using preorder traversal through the tree
	 * to rewrite the position of each child node when a node is removed
	 * 
	 * @param tempCursor
	 * @param current
	 * @param replacement
	 */
	public void renamingChildren(StoryTreeNode tempCursor, 
			StoryTreeNode current, String replacement) {
		if (tempCursor == null) {
			return;
		}
		if (tempCursor.getPosition().length() 
				== current.getPosition().length()) {
			tempCursor.setPosition(tempCursor.getPosition()
					.substring(0, current.getPosition().length()-1) 
					+ replacement);
		}
		else {
			tempCursor.setPosition(tempCursor.getPosition().substring(0, 
					current.getPosition().length()-1) + replacement 
					+ tempCursor.getPosition().substring(
							current.getPosition().length()+1, 
							tempCursor.getPosition().length()));
		}
		
		renamingChildren(tempCursor.getLeftChild(), current, replacement);
		renamingChildren(tempCursor.getMiddleChild(), current, replacement);
		renamingChildren(tempCursor.getRightChild(), current, replacement);
	}
	
	public void returnToParent() throws NodeNotPresentException {
		if (cursor.getPosition().length() <= 1 || cursor.getPosition().equals("root")) {
			throw new NodeNotPresentException("Can't go backwards");
		}
		else {
			StoryTreeNode tempCursor = root;
			String[] positionSplit = cursor.position.split("-");
			for (int i = 0; i < positionSplit.length-1; i++) {
				switch (positionSplit[i]) {
					case "1":
						tempCursor = tempCursor.getLeftChild();
						break;
					case "2":
						tempCursor = tempCursor.getMiddleChild();
						break;
					case "3":
						tempCursor = tempCursor.getRightChild();
						break;
				}
			}
			cursor = tempCursor;
		}
	}
}

